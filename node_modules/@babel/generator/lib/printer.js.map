{"version":3,"names":["isFunction","isStatement","isClassBody","isTSInterfaceBody","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","NON_DECIMAL_LITERAL","PURE_ANNOTATION_RE","needsParens","n","Printer","constructor","format","map","inForStatementInitCounter","_printStack","_indent","_indentChar","_indentRepeat","_insideAux","_parenPushNewlineState","_noLineTerminator","_printAuxAfterOnNextUserNode","_printedComments","Set","_endsWithInteger","_endsWithWord","_lastCommentLine","_endsWithInnerRaw","_indentInnerComments","_buf","Buffer","indent","style","charCodeAt","length","generate","ast","print","_maybeAddAuxComment","get","compact","concise","dedent","semicolon","force","_appendChar","_queue","rightBrace","minified","removeLastSemicolon","token","space","_space","hasContent","lastCp","getLastChar","word","str","_maybePrintInnerComments","endsWith","_append","number","Number","isInteger","test","maybeNewline","lastChar","strFirst","tokenChar","char","newline","i","retainLines","getNewlineCount","j","_newline","endsWithCharAndNewline","removeTrailingNewline","exactSource","loc","cb","_catchUp","source","prop","sourceWithOffset","lineOffset","columnOffset","withSource","_maybeAddParen","_maybeIndent","append","_maybeAddParenChar","appendChar","queue","firstChar","queueIndentation","_getIndent","_shouldIndent","parenPushNewlineState","printed","len","cha","chaPost","slice","catchUp","line","count","getCurrentLine","pos","ensureNoLineTerminator","fn","printTerminatorless","node","parent","isLabel","terminatorState","noLineTerminator","trailingCommentsLineOffset","forceParens","nodeType","type","oldConcise","_compact","printMethod","undefined","ReferenceError","JSON","stringify","name","push","oldInAux","shouldPrintParens","retainFunctionParens","extra","parenthesized","_printLeadingComments","bind","_printTrailingComments","pop","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","value","auxiliaryCommentAfter","getPossibleRaw","raw","rawValue","printJoin","nodes","opts","newlineOpts","addNewlines","nextNodeStartLine","separator","statement","_printNewline","iterator","nextNode","start","printAndIndentOnComments","leadingComments","printBlock","body","comments","trailingComments","_printComments","printInnerComments","innerComments","hasSpace","printedCommentsCount","size","noIndentInnerCommentsHere","printSequence","printList","items","commaSeparator","newLine","startLine","lastCommentLine","offset","skipNewLines","ignore","has","shouldPrintComment","add","isBlockComment","printNewLines","lastCharCode","val","adjustMultilineComment","column","newlineRegex","RegExp","replace","indentSize","getCurrentColumn","repeat","nodeLoc","hasLoc","nodeStartLine","nodeEndLine","end","lastLine","leadingCommentNewline","commentStartLine","commentEndLine","Math","max","min","singleLine","includes","shouldSkipNewline","properties","Object","assign","prototype","generatorFunctions","Noop"],"sources":["../src/printer.ts"],"sourcesContent":["import Buffer from \"./buffer\";\nimport type { Loc } from \"./buffer\";\nimport * as n from \"./node\";\nimport type * as t from \"@babel/types\";\nimport {\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n} from \"@babel/types\";\nimport type {\n  RecordAndTuplePluginOptions,\n  PipelineOperatorPluginOptions,\n} from \"@babel/parser\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport * as generatorFunctions from \"./generators\";\nimport type SourceMap from \"./source-map\";\nimport * as charCodes from \"charcodes\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\n\nconst { needsParens } = n;\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  SKIP_ALL,\n  SKIP_LEADING,\n  SKIP_TRAILING,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  retainLines: boolean;\n  retainFunctionParens: boolean;\n  comments: boolean;\n  auxiliaryCommentBefore: string;\n  auxiliaryCommentAfter: string;\n  compact: boolean | \"auto\";\n  minified: boolean;\n  concise: boolean;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  recordAndTupleSyntaxType: RecordAndTuplePluginOptions[\"syntaxType\"];\n  jsescOption: jsescOptions;\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodiesâ€™ topic references.\n   */\n  topicToken?: PipelineOperatorPluginOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n};\n\ninterface AddNewlinesOptions {\n  addNewlines(leading: boolean, node: t.Node): number;\n  nextNodeStartLine: number;\n}\n\ninterface PrintSequenceOptions extends Partial<AddNewlinesOptions> {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer) => void;\n  iterator?: (node: t.Node, index: number) => void;\n  statement?: boolean;\n  indent?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\nclass Printer {\n  constructor(format: Format, map: SourceMap) {\n    this.format = format;\n    this._buf = new Buffer(map);\n\n    this._indentChar = format.indent.style.charCodeAt(0);\n    this._indentRepeat = format.indent.style.length;\n  }\n\n  declare format: Format;\n  inForStatementInitCounter: number = 0;\n\n  declare _buf: Buffer;\n  _printStack: Array<t.Node> = [];\n  _indent: number = 0;\n  _indentChar: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _parenPushNewlineState: { printed: boolean } | null = null;\n  _noLineTerminator: boolean = false;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _endsWithInteger = false;\n  _endsWithWord = false;\n  _lastCommentLine = 0;\n  _endsWithInnerRaw: boolean = false;\n  _indentInnerComments: boolean = true;\n\n  generate(ast: t.Node) {\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(): void {\n    if (this.format.compact || this.format.concise) return;\n\n    this._indent++;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(): void {\n    if (this.format.compact || this.format.concise) return;\n\n    this._indent--;\n  }\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n\n  semicolon(force: boolean = false): void {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n    } else {\n      this._queue(charCodes.semicolon);\n    }\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.token(\"}\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== charCodes.space && lastCp !== charCodes.lineFeed) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string): void {\n    this._maybePrintInnerComments();\n\n    // prevent concatenating words and creating // comment out of division and regex\n    if (\n      this._endsWithWord ||\n      (str.charCodeAt(0) === charCodes.slash && this.endsWith(charCodes.slash))\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._append(str, false);\n\n    this._endsWithWord = true;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string): void {\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted\n    // immediately after them.\n    this._endsWithInteger =\n      Number.isInteger(+str) &&\n      !NON_DECIMAL_LITERAL.test(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot;\n  }\n\n  /**\n   * Writes a simple token.\n   */\n\n  token(str: string, maybeNewline = false): void {\n    this._maybePrintInnerComments();\n\n    // space is mandatory to avoid outputting <!--\n    // http://javascript.spec.whatwg.org/#comment-syntax\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (\n      (lastChar === charCodes.exclamationMark && str === \"--\") ||\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (strFirst === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (strFirst === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (strFirst === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._append(str, maybeNewline);\n  }\n\n  tokenChar(char: number): void {\n    this._maybePrintInnerComments();\n\n    // space is mandatory to avoid outputting <!--\n    // http://javascript.spec.whatwg.org/#comment-syntax\n    const lastChar = this.getLastChar();\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (char === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._appendChar(char);\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, force?: boolean): void {\n    if (i <= 0) return;\n\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n\n    return;\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar(): number {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline(): number {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline(): void {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!loc) return cb();\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    lineOffset: number,\n    columnOffset: number,\n  ): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, lineOffset, columnOffset);\n  }\n\n  withSource(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    cb: () => void,\n  ): void {\n    if (!loc) return cb();\n\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    this._queue(charCodes.lineFeed);\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeAddParen(str);\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _appendChar(char: number): void {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _queue(char: number) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar: number): void {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      this._buf.queueIndentation(this._indentChar, this._getIndent());\n    }\n  }\n\n  _shouldIndent(firstChar: number) {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      return true;\n    }\n  }\n\n  _maybeAddParenChar(char: number): void {\n    // see startTerminatorless() instance method\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    // This function does two things:\n    // - If needed, prints a parenthesis\n    // - If the currently printed string removes the need for the paren,\n    //   it resets the _parenPushNewlineState field.\n    //   Almost everything removes the need for a paren, except for\n    //   comments and whitespaces.\n\n    if (char === charCodes.space) {\n      // Whitespaces only, the parentheses might still be needed.\n      return;\n    }\n\n    // Check for newline or comment.\n    if (char !== charCodes.lineFeed) {\n      this._parenPushNewlineState = null;\n      return;\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _maybeAddParen(str: string): void {\n    // see startTerminatorless() instance method\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    // This function does two things:\n    // - If needed, prints a parenthesis\n    // - If the currently printed string removes the need for the paren,\n    //   it resets the _parenPushNewlineState field.\n    //   Almost everything removes the need for a paren, except for\n    //   comments and whitespaces.\n\n    const len = str.length;\n\n    let i;\n    for (i = 0; i < len && str.charCodeAt(i) === charCodes.space; i++) continue;\n    if (i === len) {\n      // Whitespaces only, the parentheses might still be needed.\n      return;\n    }\n\n    // Check for newline or comment.\n    const cha = str.charCodeAt(i);\n    if (cha !== charCodes.lineFeed) {\n      if (\n        // This is not a comment (it doesn't start with /)\n        cha !== charCodes.slash ||\n        // This is not a comment (it's a / operator)\n        i + 1 === len\n      ) {\n        // After a normal token, the parentheses aren't needed anymore\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str.charCodeAt(i + 1);\n\n      if (chaPost === charCodes.asterisk) {\n        // This is a block comment\n\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {\n          // We avoid printing newlines after #__PURE__ comments (we treat\n          // then as unary operators), but we must keep the old\n          // parenPushNewlineState because, if a newline was forbidden, it is\n          // still forbidden after the comment.\n          return;\n        }\n\n        // NOTE: code flow continues from here to after these if/elses\n      } else if (chaPost !== charCodes.slash) {\n        // This is neither a block comment, nor a line comment.\n        // After a normal token, the parentheses aren't needed anymore\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const pos = loc ? loc[prop] : null;\n    if (pos?.line != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  /**\n   * Get the current indent.\n   */\n\n  _getIndent(): number {\n    return this._indentRepeat * this._indent;\n  }\n\n  ensureNoLineTerminator(fn: () => void) {\n    const { _noLineTerminator } = this;\n    this._noLineTerminator = true;\n    fn();\n    this._noLineTerminator = _noLineTerminator;\n  }\n\n  printTerminatorless(node: t.Node, parent: t.Node, isLabel: boolean) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    if (isLabel) {\n      this.ensureNoLineTerminator(() => {\n        this.print(node, parent);\n      });\n    } else {\n      const terminatorState = {\n        printed: false,\n      };\n      this._parenPushNewlineState = terminatorState;\n      this.print(node, parent);\n      /**\n       * Print an ending parentheses if a starting one has been printed.\n       */\n      if (terminatorState.printed) {\n        this.dedent();\n        this.newline();\n        this.token(\")\");\n      }\n    }\n  }\n\n  print(\n    node: t.Node | null,\n    parent?: t.Node,\n    noLineTerminator?: boolean,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminator||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n    forceParens?: boolean,\n  ) {\n    if (!node) return;\n\n    this._endsWithInnerRaw = false;\n\n    const nodeType = node.type;\n    const format = this.format;\n\n    const oldConcise = format.concise;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      format.concise = true;\n    }\n\n    const printMethod =\n      this[\n        nodeType as Exclude<\n          t.Node[\"type\"],\n          // removed\n          | \"Noop\"\n          // renamed\n          | t.DeprecatedAliases[\"type\"]\n        >\n      ];\n    if (printMethod === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          nodeType,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == undefined;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let shouldPrintParens = false;\n    if (forceParens) {\n      shouldPrintParens = true;\n    } else if (\n      format.retainFunctionParens &&\n      nodeType === \"FunctionExpression\" &&\n      node.extra &&\n      node.extra.parenthesized\n    ) {\n      shouldPrintParens = true;\n    } else {\n      shouldPrintParens = needsParens(node, parent, this._printStack);\n    }\n    if (shouldPrintParens) this.token(\"(\");\n\n    this._lastCommentLine = 0;\n\n    this._printLeadingComments(node, parent);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n\n    this.exactSource(loc, printMethod.bind(this, node, parent));\n\n    if (noLineTerminator && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n      this._noLineTerminator = false;\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n\n    if (shouldPrintParens) this.token(\")\");\n\n    // end\n    this._printStack.pop();\n\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n\n    this._endsWithInnerRaw = false;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DecimalLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra &&\n      extra.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: Array<t.Node> | undefined | null,\n    parent: t.Node,\n    opts: PrintJoinOptions = {},\n  ) {\n    if (!nodes?.length) return;\n\n    if (opts.indent) this.indent();\n\n    const newlineOpts: AddNewlinesOptions = {\n      addNewlines: opts.addNewlines,\n      nextNodeStartLine: 0,\n    };\n\n    const separator = opts.separator ? opts.separator.bind(this) : null;\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      if (opts.statement) this._printNewline(i === 0, newlineOpts);\n\n      this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);\n\n      opts.iterator?.(node, i);\n\n      if (i < len - 1) separator?.();\n\n      if (opts.statement) {\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;\n\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node: t.Node, parent: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent: Extract<t.Node, { body: t.Statement }>) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node: t.Node, parent?: t.Node, lineOffset?: number) {\n    const comments = node.trailingComments;\n    if (!comments?.length) return;\n    this._printComments(\n      COMMENT_TYPE.TRAILING,\n      comments,\n      node,\n      parent,\n      lineOffset,\n    );\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments() {\n    if (this._endsWithInnerRaw) this.printInnerComments();\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n\n  printInnerComments() {\n    const node = this._printStack[this._printStack.length - 1];\n    const comments = node.innerComments;\n    if (!comments?.length) return;\n\n    const hasSpace = this.endsWith(charCodes.space);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(COMMENT_TYPE.INNER, comments, node);\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    parent: t.Node,\n    opts: PrintSequenceOptions = {},\n  ) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items: t.Node[], parent: t.Node, opts: PrintListOptions = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(newLine: boolean, opts: AddNewlinesOptions) {\n    // Fast path since 'this.newline' does nothing when not tracking lines.\n    if (this.format.retainLines || this.format.compact) return;\n\n    // Fast path for concise since 'this.newline' just inserts a space when\n    // concise formatting is in use.\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    if (!newLine) {\n      return;\n    }\n\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n\n    // don't add newlines at the beginning of the file\n    if (this._buf.hasContent()) {\n      // Here is the logic of the original line wrapping according to the node layout, we are not using it now.\n      // We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.\n\n      // let lines = 0;\n      // if (!leading) lines++; // always include at least a single line after\n      // if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      // const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      // if (needs(node, parent)) lines++;\n\n      // this.newline(Math.min(2, lines));\n\n      this.newline(1);\n    }\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE): void {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return;\n\n    if (this._printedComments.has(comment)) return;\n\n    if (!this.format.shouldPrintComment(comment.value)) return;\n\n    this._printedComments.add(comment);\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.SKIP_ALL &&\n      !this._noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.SKIP_LEADING\n    ) {\n      this.newline(1);\n    }\n\n    const lastCharCode = this.getLastChar();\n    if (\n      lastCharCode !== charCodes.leftSquareBracket &&\n      lastCharCode !== charCodes.leftCurlyBrace\n    ) {\n      this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n\n        let indentSize = this.format.retainLines\n          ? 0\n          : this._buf.getCurrentColumn();\n\n        if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {\n          indentSize += this._getIndent();\n        }\n\n        val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n      }\n    } else if (!this._noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      val = `/*${comment.value}*/`;\n    }\n\n    // Avoid creating //* comments\n    if (this.endsWith(charCodes.slash)) this._space();\n\n    this.source(\"start\", comment.loc);\n    this._append(val, isBlockComment);\n\n    if (!isBlockComment && !this._noLineTerminator) {\n      this.newline(1, true);\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.SKIP_TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: readonly t.Comment[],\n    node: t.Node,\n    parent?: t.Node,\n    lineOffset: number = 0,\n  ) {\n    {\n      const nodeLoc = node.loc;\n      const len = comments.length;\n      let hasLoc = !!nodeLoc;\n      const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n      const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n      let lastLine = 0;\n      let leadingCommentNewline = 0;\n\n      for (let i = 0; i < len; i++) {\n        const comment = comments[i];\n\n        if (hasLoc && comment.loc && !this._printedComments.has(comment)) {\n          const commentStartLine = comment.loc.start.line;\n          const commentEndLine = comment.loc.end.line;\n          if (type === COMMENT_TYPE.LEADING) {\n            let offset = 0;\n            if (i === 0) {\n              // Because currently we cannot handle blank lines before leading comments,\n              // we always wrap before and after multi-line comments.\n              if (\n                this._buf.hasContent() &&\n                (comment.type === \"CommentLine\" ||\n                  commentStartLine != commentEndLine)\n              ) {\n                offset = leadingCommentNewline = 1;\n              }\n            } else {\n              offset = commentStartLine - lastLine;\n            }\n            lastLine = commentEndLine;\n\n            this.newline(offset);\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.SKIP_ALL);\n\n            if (i + 1 === len) {\n              this.newline(\n                Math.max(nodeStartLine - lastLine, leadingCommentNewline),\n              );\n              lastLine = nodeStartLine;\n            }\n          } else if (type === COMMENT_TYPE.INNER) {\n            const offset =\n              commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n            lastLine = commentEndLine;\n\n            this.newline(offset);\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.SKIP_ALL);\n\n            if (i + 1 === len) {\n              this.newline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger\n              lastLine = nodeEndLine;\n            }\n          } else {\n            const offset =\n              commentStartLine -\n              (i === 0 ? nodeEndLine - lineOffset : lastLine);\n            lastLine = commentEndLine;\n\n            this.newline(offset);\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.SKIP_ALL);\n          }\n        } else {\n          hasLoc = false;\n\n          if (len === 1) {\n            const singleLine = comment.loc\n              ? comment.loc.start.line === comment.loc.end.line\n              : !comment.value.includes(\"\\n\");\n\n            const shouldSkipNewline =\n              singleLine &&\n              !isStatement(node) &&\n              !isClassBody(parent) &&\n              !isTSInterfaceBody(parent);\n\n            if (type === COMMENT_TYPE.LEADING) {\n              this._printComment(\n                comment,\n                (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                  (singleLine && isFunction(parent, { body: node }))\n                  ? COMMENT_SKIP_NEWLINE.SKIP_ALL\n                  : COMMENT_SKIP_NEWLINE.DEFAULT,\n              );\n            } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n              this._printComment(comment, COMMENT_SKIP_NEWLINE.SKIP_ALL);\n            } else {\n              this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n            }\n          } else if (\n            type === COMMENT_TYPE.INNER &&\n            !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n            node.type !== \"ClassBody\" &&\n            node.type !== \"TSInterfaceBody\"\n          ) {\n            // class X {\n            //   /*:: a: number*/\n            //   /*:: b: ?string*/\n            // }\n\n            this._printComment(\n              comment,\n              i === 0\n                ? COMMENT_SKIP_NEWLINE.SKIP_LEADING\n                : i === len - 1\n                ? COMMENT_SKIP_NEWLINE.SKIP_TRAILING\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        }\n      }\n\n      if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n        this._lastCommentLine = lastLine;\n      }\n    }\n  }\n}\n\n// Expose the node type functions and helpers on the prototype for easy usage.\nObject.assign(Printer.prototype, generatorFunctions);\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-ignore(Babel 7 vs Babel 8) Babel 7 has Noop print method\n  Printer.prototype.Noop = function Noop(this: Printer) {};\n}\n\ntype GeneratorFunctions = typeof generatorFunctions;\ninterface Printer extends GeneratorFunctions {}\nexport default Printer;\n\nfunction commaSeparator(this: Printer) {\n  this.token(\",\");\n  this.space();\n}\n"],"mappings":"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"}